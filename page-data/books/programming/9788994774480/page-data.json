{"componentChunkName":"component---src-templates-blog-post-js","path":"/books/programming/9788994774480/","result":{"data":{"site":{"siteMetadata":{"title":"WEET 📚","author":"weet","siteUrl":"http://weet.io","comment":{"disqusShortName":"","utterances":""}}},"markdownRemark":{"id":"c67e3a06-de6b-51d8-aa45-40cbc53cbc0f","excerpt":"…","html":"<div class=\"gatsby-remark-grid-system row\"><div class=\"gatsby-remark-grid-system col col-12 col-sm-12 col-md-5 col-lg-5 col-xl-5\"><p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 200px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 140%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAcABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBP/EABcBAQADAAAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAeLUzlU2TIoYH//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBExIf/aAAgBAQABBQIdlIedGbGy2f/EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BH//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BH//EABUQAQEAAAAAAAAAAAAAAAAAACEw/9oACAEBAAY/Ain/xAAeEAEAAgICAwEAAAAAAAAAAAABABExQRAhUWFxgf/aAAgBAQABPyENts1LAMD4n6fZbD1Oid8Lw3Ad0y9IdmOKHBP/2gAMAwEAAgADAAAAEPvSvf/EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxC6kY1//8QAFhEBAQEAAAAAAAAAAAAAAAAAEBEh/9oACAECAQE/EMKf/8QAHhABAQACAgIDAAAAAAAAAAAAAREAITFRQXFhgaH/2gAIAQEAAT8QcWAFEhr1idKmXk/mIBCewXn1krRQis685Aoa73gFH4xgkIlvjWvvDoqGBAhnjIBRsGHfeaeSzjJQbCr3n//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"9788994774480 L\"\n        title=\"9788994774480 L\"\n        src=\"/static/0dcd4c79eecf50877a6f265572f642a7/9c38a/9788994774480_L.jpg\"\n        srcset=\"/static/0dcd4c79eecf50877a6f265572f642a7/dd4e5/9788994774480_L.jpg 50w,\n/static/0dcd4c79eecf50877a6f265572f642a7/ae1bf/9788994774480_L.jpg 100w,\n/static/0dcd4c79eecf50877a6f265572f642a7/9c38a/9788994774480_L.jpg 200w\"\n        sizes=\"(max-width: 200px) 100vw, 200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p></div><div class=\"gatsby-remark-grid-system col col-12 col-sm-12 col-md-7 col-lg-7 col-xl-7\"><p>이 책은 프로그래밍 언어가 가지고 있는 다양한 개념이 ‘왜’ 존재하고 있는지를 설명한다. 세상에는 많은 프로그래밍 언어가 있으며 관련된 개념도 함수, 형, 스코프, 클래스, 상속 등 그 수를 헤아릴 수 없을 정도로 다양하다. 많은 프로그래밍 언어에서 공통적으로 사용하고 있는 개념도 있지만, 일부 언어만 채용하고 있는 개념도 많다. 이런 개념들은 ‘왜’ 탄생한 것일까? 본서의 목적은 그 이유를 알아내는 것이다.</p><p>이를 위해, 이 책은 언어 설계자의 관점에서 여러 언어를 비교하고 언어가 어떻게 변화되어 왔는지를 설명한다. 다양한 개념이 ‘왜’ 탄생했는지를 이해하게 되면 각 언어를 왜, 언제, 어떻게 사용해야 할지를 판단할 수 있게 된다. 또한 이후에 생겨날 새로운 개념도 쉽게 이해할 수 있는 밑거름이 될 것이다.</p><p>이 책은 프로그램 개발에 대한 핵심 개념을 쉽게 이해할 수 있어 개발자뿐만 아니라, 시스템 설계자나 관리자들에게도 큰 도움이 될 것이다.</p></div></div>\n<h3 id=\"책-키워드\" style=\"position:relative;\"><a href=\"#%EC%B1%85-%ED%82%A4%EC%9B%8C%EB%93%9C\" aria-label=\"책 키워드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>책 키워드</h3>\n<p><span class=\"badge badge-pill badge-danger\">프로그래밍 책 추천</span>\n<span class=\"badge badge-pill badge-primary\">프로그래밍 원리</span>\n<span class=\"badge badge-pill badge-primary\">프로그래밍 개념</span>\n<span class=\"badge badge-pill badge-warning\">초보 개발자</span>\n<span class=\"badge badge-pill badge-info\">IT에 몸담은 이들을 위한 지적 생산 기술</span></p>\n<h2 id=\"출판사-서평\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%ED%8C%90%EC%82%AC-%EC%84%9C%ED%8F%89\" aria-label=\"출판사 서평 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출판사 서평</h2>\n<p><code class=\"language-text\">이 책의 목적은 여러분의 ‘왜’를 해결하는 것이다</code>\n초보에서 한 단계 깊은 단계를 고민하는 법을 알려주는 책\n코딩의 원리를 이해하다</p>\n<p>세상에는 수많은 프로그래밍 언어가 존재한다. 읽어야 할 문서도 셀 수 없을 정도다. 하지만 여러분이 가지고 있는 시간은 제한되어 있어 모든 것을 습득하기엔 역부족이다.</p>\n<p>또한 기술 변화 속도가 너무 빨라서 특정 언어나 툴에 관한 지식은 금방 쓸모 없게 된다. ‘변화하고 있는 지식’을 꾸준히 습득하지 않으면, 이미 학습한 지식도 점점 가치를 잃게 된다.</p>\n<p>그러면 무엇을 학습하면 되는 것일까? 학습에는 3가지 중요한 포인트가 있다.</p>\n<ul>\n<li>비교를 통한 학습</li>\n<li>역사를 통한 학습</li>\n<li>만드는 것을 통한 학습</li>\n</ul>\n<p>첫 번째는 다수의 언어를 비교하는 것이다. 무엇이 그 언어만이 가진 특유의 개념이고, 무엇이 언어 간에 공통으로 사용되는 개념인지를 배울 수 있다.</p>\n<p>두 번째는 언어의 발달 과정을 따라가는 것이다. 어떻게 탄생했고, 어떤 식으로 변화해 왔는지를 배움으로 ‘왜 이런 식으로 동작하고 있는지’에 대한 의문을 풀 수 있다.</p>\n<p>세 번째는 직접 언어를 만드는 것이다. ‘나라면 어떻게 만들까?’를 생각함으로, 언어 설계자의 의도를 쉽게 이해할 수 있게 된다. 또한 실제로 만들어 봄으로써 자신이 잘 이해하지 못한 것을 알 수 있게 된다.</p>\n<p>독자 여러분도 지금까지 다양한 책을 읽으면서 분명 ‘왜’라는 의문을 가진 적이 있을 것이다. 이 책의 목적은 여러분의 ‘왜’를 해결하는 것이다. 프로그래밍에 익숙하지 않은 독자들을 위해 ‘비교를 통한 학습’과 ‘역사를 통한 학습’ 방법에 많은 분량을 할애하고 있다. 이런 학습 방법 자체를 여러분들이 익힐 수 있다면, 이 책으로서는 대성공한 것이다.</p>\n<p>예제코드 다운로드\n<a href=\"http://nhiro.org/langbook/\">http://nhiro.org/langbook/</a>\n<a href=\"https://github.com/nishio/learn_language/tree/master/langbook\">https://github.com/nishio/learn_language/tree/master/langbook</a></p>\n<h2 id=\"저자-소개\" style=\"position:relative;\"><a href=\"#%EC%A0%80%EC%9E%90-%EC%86%8C%EA%B0%9C\" aria-label=\"저자 소개 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>저자 소개</h2>\n<p><code class=\"language-text\">저자 : 니시오 히로카즈</code>\n저자 니시오 히로카즈는 24살에 이학 박사 취득, 2007년부터 사이보즈 랩(CYBOZU LABS)에서 연구원으로 근무하고 있다. ‘시큐리티 &#x26; 프로그래밍 캠프 2011’에서 프로그래밍 언어 수업 관리 대표로 근무한 경험이 있고, 소프트웨어를 사용한 지식 창조 효율화와 소프트웨어 설계, 진화에 관심이 있다. 저서로는 《JYTHON 프로그래밍》, WEB+DB PRESS VOL.60 특집인 《프로그래머가 알아야 할 언어 설계 기본 지식》 등이 있다.</p>\n<p><code class=\"language-text\">역자 : 김완섭</code>\n역자 김완섭은 대학에서 지리정보 공학을 전공했다. 일본에서 시스템 엔니지어로 5년간 근무했다. 일본 보험시스템 개발 담당을 시작으로, 일본 대기업 세콤(SECOM) 계열사인 파스코(PASCO)에서 일본 외무성, 일본 국토지리정보원 등 일본 정부기관을 대상으로 한 시스템 통합(SI) 업무를 담당했다. 이후 야후 재팬(YAHOO JAPAN)으로 직장을 옮겨 야후 맵(YAHOO MAP) 개발 담당 시니어 엔지니어로 근무하다가 2010년 귀국하여 SK에서 내비게이션 데이터 담당 매니저로 일했다. 지금은 또 다른 꿈을 찾아서 네덜란드에서 공부중에 있다. 역서로는 『서버 부하분산 입문』(제이펍)이 있다.</p>\n<h2 id=\"목차\" style=\"position:relative;\"><a href=\"#%EB%AA%A9%EC%B0%A8\" aria-label=\"목차 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>목차</h2>\n<p>1장 효율적으로 언어 배우기<br/>\n<br/>\n1.1 비교를 통한 배움<br/></p>\n<ul>\n<li>규칙은 언어마다 다르다<br/></li>\n<li>C 언어와 Ruby의 참거짓 값<br/></li>\n<li>Java의 참거짓 값<br/>\n<br/>\n1.2 역사를 통한 배움<br/></li>\n<li>언어 설계자의 의도를 이해하자<br/></li>\n<li>어떤 언어를 배워야 하는지는 아무도 모른다<br/></li>\n<li>언어에 의존하지 않는 보편적인 지식의 습득<br/>\n<br/>\n2장 프로그래밍 언어를 조감하다<br/>\n<br/>\n2.1 프로그래밍 언어 탄생의 역사<br/></li>\n<li>케이블을 연결하다<br/></li>\n<li>프로그램 내장 방식으로<br/></li>\n<li>FORTRAN의 등장<br/>\n<br/>\n2.2 프로그래밍 언어 탄생의 목적<br/></li>\n<li>나태 ? 프로그래머의 삼대 미덕<br/></li>\n<li>언어에 따라 다른 ‘편리함’의 의미<br/>\n<br/>\n3장 문법의 탄생<br/>\n<br/>\n3.1 문법이란?<br/></li>\n<li>연산자 우선순위<br/></li>\n<li>문법은 언어 설계자가 정한 규칙<br/>\n<br/>\n3.2 스택 머신과 FORTH<br/></li>\n<li>계산 순서<br/></li>\n<li>연산 순서를 어떻게 표현할까?<br/></li>\n<li>현재도 살아있는 스택 머신<br/>\n<br/>\n3.3 구문 트리와 LISP<br/></li>\n<li>계산의 흐름<br/></li>\n<li>계산 순서를 어떻게 표현할까?<br/></li>\n<li>현재도 살아있는 구문 트리<br/>\n칼럼: 이해력을 확인하기 위해서는 결과물(Output)을 확인한다<br/>\n<br/>\n3.4 중위 표기법<br/></li>\n<li>구문 해석기<br/>\n칼럼: 무엇을 배우면 좋을지 모르는 이유<br/></li>\n<li>규칙간 마찰<br/>\n<br/>\n4장 처리 흐름 제어<br/>\n<br/>\n4.1 구조화 프로그래밍의 탄생<br/>\n<br/>\n4.2 if가 탄생하기 전<br/></li>\n<li>if는 왜 있는 걸까?<br/></li>\n<li>If-else는 왜 있는 걸까?<br/>\n<br/>\n4.3 while, 반복되는 if를 읽기 쉽게 표현<br/></li>\n<li>while 문을 사용하는 방법<br/></li>\n<li>while 문을 사용하지 않는 방법<br/>\n<br/>\n4.4 for, 수치를 증가시키는 while을 읽기 쉽게 표현<br/></li>\n<li>for를 사용하는 방법<br/></li>\n<li>for를 사용하지 않는 방법<br/></li>\n<li>foreach, 처리 대상으로 반복 제어<br/>\n<br/>\n5장 함수<br/>\n<br/>\n5.1 함수의 역할<br/></li>\n<li>이해(조직을 예로)<br/></li>\n<li>재사용(부품을 예로)<br/></li>\n<li>프로그램 재사용의 특징<br/>\n<br/>\n5.2 돌아가는 명령<br/></li>\n<li>함수의 탄생<br/></li>\n<li>돌아갈 목적지를 기록하기 위한 전용 메모리<br/>\n칼럼: 이름<br/></li>\n<li>스택<br/>\n<br/>\n5.3 재귀 호출<br/></li>\n<li>내포 구조 데이터의 효율적 처리<br/></li>\n<li>내포 구조를 다루는 방법<br/>\n<br/>\n6장 에러 처리<br/>\n<br/>\n6.1 프로그램도 실패를 한다<br/>\n<br/>\n6.2 실패를 어떻게 전달할까?<br/></li>\n<li>반환값으로 실패를 전달한다<br/></li>\n<li>실패하면 점프한다<br/>\n<br/>\n6.3 실패할 것 같은 처리를 묶는 구문<br/></li>\n<li>John Good enough의 주장<br/></li>\n<li>CLU에 도입<br/></li>\n<li>C++에 도입<br/></li>\n<li>Windows NT 3.1에 도입<br/>\n<br/>\n6.4 출구는 하나다<br/></li>\n<li>왜 finally를 도입한 것일까?<br/></li>\n<li>짝이 되는 처리를 반드시 실행한다<br/>\n<br/>\n6.5 어떤 경우에 예외를 던질까?<br/></li>\n<li>함수 호출 시 인수가 부족한 경우<br/></li>\n<li>배열 범위 밖에 있는 것을 취득하려고 했을 때<br/></li>\n<li>틀리면 바로 예외를 던진다<br/>\n<br/>\n6.6 예외의 전파<br/></li>\n<li>예외 전파의 문제점<br/></li>\n<li>Java의 검사 예외<br/></li>\n<li>검사 예외가 잘 사용되지 않는 이유<br/>\n컬럼: 구체적인 지식과 추상적인 지식<br/>\n칼럼: 이빨로 씹다<br/>\n칼럼: 필요한 부분부터 흡수한다<br/>\n<br/>\n7장 이름과 스코프<br/>\n<br/>\n7.1 왜 이름이 필요할까?<br/></li>\n<li>어떻게 이름을 붙일까?<br/></li>\n<li>이름 충돌<br/></li>\n<li>충돌 피하기<br/>\n<br/>\n7.2 스코프의 진화<br/></li>\n<li>동적 스코프<br/></li>\n<li>정적 스코프<br/>\n<br/>\n7.3 정적 스코프는 완성체인가?<br/>\n칼럼: 다른 언어의 스코프<br/></li>\n<li>내포 함수의 문제점<br/></li>\n<li>외부 스코프에 재귀속되는 문제<br/>\n<br/>\n8장 형<br/>\n<br/>\n8.1 형(型)이란?<br/>\n<br/>\n8.2 수치를 On과 Off로 표현하는 방법<br/></li>\n<li>자릿수 발명<br/></li>\n<li>7 세그먼트 디스플레이<br/></li>\n<li>주판<br/>\n<br/>\n8.3 한 자리에 필요한 램프는 몇 개일까?<br/></li>\n<li>10 진수에서 2 진수로<br/></li>\n<li>8 진수와 16 진수<br/>\n<br/>\n8.4 실수는 어떻게 표현할까?<br/></li>\n<li>고정 소수점 ? 소수점을 어디에 붙일지 정한다<br/></li>\n<li>부동 소수점 ? 어디부터 소수부인지의 정보 자체를 값에 포함시킨다<br/>\n<br/>\n8.5 형은 무엇을 위해 존재할까?<br/></li>\n<li>형이 없을 때 발생하는 문제<br/></li>\n<li>초기 FORTRAN의 형<br/></li>\n<li>언어 처리계에 변수 종류를 알린다<br/></li>\n<li>암묵의 형 승격<br/>\n<br/>\n8.6 형의 다양한 전개<br/></li>\n<li>사용자 정의형과 객체 지향<br/></li>\n<li>사양으로서 형<br/></li>\n<li>총칭형, 제네릭스, 템플릿<br/></li>\n<li>동적 형결정<br/></li>\n<li>형 추론<br/>\n칼럼: 대략적인 부분을 잡아서 조금씩 상세화한다<br/>\n<br/>\n9장 컨테이너와 문자열<br/>\n<br/>\n9.1 다양한 종류의 컨테이너<br/>\n<br/>\n9.2 왜 다양한 컨테이너가 존재할까?<br/></li>\n<li>배열과 연결 리스트<br/></li>\n<li>연결 리스트의 장단점<br/>\n칼럼: O 기법 ? 계산 시간과 데이터량의 관계를 간단히 나타내는 것<br/></li>\n<li>언어에 따른 차이<br/>\n<br/>\n9.3 사전, 해쉬, 연상 배열<br/></li>\n<li>해쉬 테이블<br/></li>\n<li>트리<br/></li>\n<li>요소를 꺼내는 시간<br/></li>\n<li>만능 컨테이너란 없다<br/>\n<br/>\n9.4 문자란?<br/></li>\n<li>문자 집합과 문자 부호화 방식<br/></li>\n<li>컴퓨터 이전 시대의 부호화<br/></li>\n<li>EDSAC 문자 코드<br/></li>\n<li>ASCII와 EBCDIC 시대<br/></li>\n<li>Unicode에 의한 통일<br/>\n<br/>\n9.5 문자열이란?<br/></li>\n<li>길이 정보를 가지고 있는 Pascal 문자열, 가지고 있지 않은 C 문자열<br/></li>\n<li>한 문자가 16 비트인 Java 문자열<br/></li>\n<li>Python 3에서 이루어진 설계 변경<br/></li>\n<li>Ruby 1.9의 도전<br/>\n<br/>\n10장 병행 처리<br/>\n<br/>\n10.1 병행 처리란?<br/>\n<br/>\n10.2 잘게 분할해서 실행한다<br/>\n<br/>\n10.3 처리를 변경하는 2가지 방법<br/></li>\n<li>협력적 멀티태스크<br/></li>\n<li>선점적 멀티태스크 ? 일정 시간에 교대한다<br/>\n<br/>\n10.4 경합 상태 방지법<br/></li>\n<li>경합 상태의 3가지 조건<br/></li>\n<li>공유하지 않는다 ? 프로세스와 액터 모델<br/></li>\n<li>변경하지 않는다 ? const, val, Immutable<br/></li>\n<li>끼어들지 않는다<br/>\n<br/>\n10.5 락의 문제점과 해결책<br/></li>\n<li>락의 문제점<br/></li>\n<li>트랜잭션 메모리<br/></li>\n<li>트랜잭션 메모리의 역사<br/>\n트랜잭션 메모리는 성공할까?<br/>\n<br/>\n11장 객체와 클래스<br/>\n<br/>\n11.1 객체 지향이란?<br/></li>\n<li>객체는 현실 세계의 모형<br/></li>\n<li>클래스란?<br/>\n<br/>\n11.2 변수와 함수를 합쳐서 모형을 만드는 법<br/>\n<br/>\n11.3 방법 1: 모듈, 패키지<br/></li>\n<li>모듈, 패키지란 무엇인가?<br/></li>\n<li>Perl 패키지로 객체를 만든다<br/></li>\n<li>모듈만으로는 부족하다<br/></li>\n<li>별도의 데이터 저장소를 만든다<br/></li>\n<li>인수로 개별 해쉬를 전달한다<br/></li>\n<li>초기화 처리도 패키지에 넣는다<br/></li>\n<li>해쉬와 패키지를 연결한다<br/>\n<br/>\n11.4 방법 2: 함수도 해쉬에 넣는다<br/></li>\n<li>퍼스트 클래스<br/></li>\n<li>함수를 해쉬에 넣는다<br/></li>\n<li>복수 개 카운터를 만든다<br/></li>\n<li>공유하고 있는 사물을 프로토타입으로 이동한다<br/></li>\n<li>이것이 객체 지향?<br/>\n<br/>\n11.5 방법 3: 클로저<br/></li>\n<li>클로저란?<br/></li>\n<li>왜 클로저라고 부를까?<br/>\n<br/>\n11.6 방법 4: 클래스<br/></li>\n<li>Hoare가 생각한 클래스<br/></li>\n<li>C++ 클래스<br/></li>\n<li>사양으로서 역할<br/></li>\n<li>클래스의 3가지 역할<br/>\n<br/>\n12장 상속을 통한 재사용<br/>\n<br/>\n12.1 상속이란?<br/></li>\n<li>상속에 관한 다양한 접근법<br/></li>\n<li>상속은 양날의 칼<br/></li>\n<li>리스코프의 치환 원칙<br/>\n<br/>\n12.2 다중 상속<br/></li>\n<li>하나의 사물을 복수로 분류<br/></li>\n<li>코드 재사용에 편리한 다중 상속<br/>\n<br/>\n12.3 다중 상속의 문제점 ? 거듭되는 충돌<br/></li>\n<li>해결책 1: 다중 상속을 금지한다<br/></li>\n<li>해결책 2: 메소드 해결 순서를 고민한다<br/></li>\n<li>해결책 3: 처리를 섞는다<br/></li>\n<li>해결책 4: 트레이트<br/>\n칼럼: 끝에서부터 차례대로 베껴간다</li>\n</ul>\n<h2 id=\"책-정보\" style=\"position:relative;\"><a href=\"#%EC%B1%85-%EC%A0%95%EB%B3%B4\" aria-label=\"책 정보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>책 정보</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>저자</td>\n<td align=\"center\">니시오 히로카즈</td>\n</tr>\n<tr>\n<td>출판사</td>\n<td align=\"center\">비제이퍼블릭</td>\n</tr>\n<tr>\n<td>출간일</td>\n<td align=\"center\">2013.10.17</td>\n</tr>\n<tr>\n<td>ISBN</td>\n<td align=\"center\">9788994774480</td>\n</tr>\n<tr>\n<td>쪽수</td>\n<td align=\"center\">244쪽</td>\n</tr>\n<tr>\n<td>크기</td>\n<td align=\"center\">150*210mm</td>\n</tr>\n<tr>\n<td>무게</td>\n<td align=\"center\">385g</td>\n</tr>\n</tbody>\n</table>\n<p>파트너스 활동을 통해 일정액의 수수료를 제공받을 수 있음</p>","frontmatter":{"title":"코딩을 지탱하는 기술 (원리로 깨우치는 프로그래밍 기법)","tags":["프로그래밍 책 추천","프로그래밍 원리","프로그래밍 개념","프로그래머","초보 개발자","코딩 기술","프로그래밍 기술","IT에 몸담은 이들을 위한 지적 생산 기술"],"naverOrder":"https://smartstore.naver.com/weetbook/products/4776830493","coupangOrder":"https://coupa.ng/bmtUOK","date":"2013.10.17"}}},"pageContext":{"slug":"/books/programming/9788994774480/","previous":{"fields":{"slug":"/books/programming/9788994774299/"},"frontmatter":{"title":"리눅스 커맨드라인 완벽 입문서","category":"linux","draft":false}},"next":{"fields":{"slug":"/books/programming/9788997924240/"},"frontmatter":{"title":"자바 웹 프로그래밍 Next Step","category":"programming","draft":false}}}}}